#necssary packages: 
from midiutil import MIDIFile #this package enables us to create an audo file
from mingus.core import chords #this package uses music principles to define certain elements of our code (including what different chord or note names represent)
import pandas as pd

#this is a filler csv file that I used in my own visual studio 
filename = "songs.csv"
df = pd.read_csv(filename)
df

song_name = df['song_name']
song_chords = df['song_chords'].str.split(', ').explode()

# Given dictionary
#plugged in demo value
my_dict = {'0': ('N', '4'), '1': ('E:min', '4'), '2': ('E:min', '4'), '3': ('D:maj', '4'), '4': ('D:maj', '4'), '5': ('E:min', '4'), '6': ('E:min', '4'), '7': ('D:maj', '4'), '8': ('D:maj', '4'), '9': ('E:min', '4'), '10': ('E:min', '4'), '11': ('D:maj', '4'), '12': ('D:maj', '4'), '13': ('C:maj', '4'), '14': ('C:maj', '4'), '15': ('C:maj', '4'), '16': ('C:maj', '4'), '17': ('E:min', '4'), '18': ('E:min', '4'), '19': ('D:maj', '4'), '20': ('D:maj', '4'), '21': ('E:min', '4'), '22': ('E:min', '4'), '23': ('D:maj', '4'), '24': ('D:maj', '4'), '25': ('E:min', '4'), '26': ('E:min', '4'), '27': ('D:maj', '4'), '28': ('D:maj', '4'), '29': ('C:maj', '4'), '30': ('C:maj', '4'), '31': ('C:maj', '4'), '32': ('C:maj', '4'), '33': ('E:min', '4'), '34': ('E:min', '4'), '35': ('D:maj', '4'), '36': ('D:maj', '4'), '37': ('E:min', '4'), '38': ('E:min', '4'), '39': ('D:maj', '4'), '40': ('D:maj', '4'), '41': ('E:min', '4'), '42': ('E:min', '4'), '43': ('D:maj', '4'), '44': ('D:maj', '4'), '45': ('C:maj', '4'), '46': ('C:maj', '4'), '47': ('C:maj', '4'), '48': ('C:maj', '4'), '49': ('G:maj', '4'), '50': ('G:maj', '4'), '51': ('D:maj', '4'), '52': ('D:maj', '4'), '53': ('A:min', '4'), '54': ('A:min', '4'), '55': ('E:min', '4'), '56': ('E:min', '4'), '57': ('G:maj', '4'), '58': ('D:maj', '4'), '59': ('A:min', '4'), '60': ('A:min', '4'), '61': ('E:min', '4'), '62': ('E:min', '4'), '63': ('E:min', '4'), '64': ('E:min', '4'), '65': ('E:min', '4'), '66': ('E:min', '4'), '67': ('D:maj', '4'), '68': ('D:maj', '4'), '69': ('E:min', '4'), '70': ('E:min', '4'), '71': ('D:maj', '4'), '72': ('D:maj', '4'), '73': ('E:min', '4'), '74': ('E:min', '4'), '75': ('D:maj', '4'), '76': ('D:maj', '4'), '77': ('C:maj', '4'), '78': ('C:maj', '4'), '79': ('C:maj', '4'), '80': ('C:maj', '4'), '81': ('E:min', '4'), '82': ('E:min', '4'), '83': ('D:maj', '4'), '84': ('D:maj', '4'), '85': ('E:min', '4'), '86': ('E:min', '4'), '87': ('D:maj', '4'), '88': ('D:maj', '4'), '89': ('E:min', '4'), '90': ('E:min', '4'), '91': ('D:maj', '4'), '92': ('D:maj', '4'), '93': ('C:maj', '4'), '94': ('C:maj', '4'), '95': ('C:maj', '4'), '96': ('C:maj', '4'), '97': ('G:maj', '4'), '98': ('G:maj', '4'), '99': ('D:maj', '4'), '100': ('D:maj', '4'), '101': ('A:min', '4'), '102': ('A:min', '4'), '103': ('E:min', '4'), '104': ('E:min', '4'), '105': ('G:maj', '4'), '106': ('G:maj', '4'), '107': ('D:maj', '4'), '108': ('D:maj', '4'), '109': ('A:min', '4'), '110': ('A:min', '4'), '111': ('E:min', '4'), '112': ('E:min', '4'), '113': ('G:maj', '4'), '114': ('G:maj', '4'), '115': ('D:maj', '4'), '116': ('D:maj', '4'), '117': ('A:min', '4'), '118': ('A:min', '4'), '119': ('E:min', '4'), '120': ('E:min', '4'), '121': ('G:maj', '4'), '122': ('G:maj', '4'), '123': ('D:maj', '4'), '124': ('D:maj', '4'), '125': ('A:min', '4'), '126': ('A:min', '4'), '127': ('E:min', '4'), '128': ('E:min', '4'), '129': ('E:min', '4'), '130': ('E:min', '4'), '131': ('B:min', '4'), '132': ('B:min', '4'), '133': ('E:min', '4'), '134': ('E:min', '4'), '135': ('A:min', '4'), '136': ('A:min', '4'), '137': ('G:maj', '4'), '138': ('G:maj', '4'), '139': ('B:min', '4'), '140': ('B:min', '4'), '141': ('E:min', '4'), '142': ('E:min', '4'), '143': ('A:min', '4'), '144': ('A:min', '4'), '145': ('G:maj', '4'), '146': ('G:maj', '4'), '147': ('B:min', '4'), '148': ('B:min', '4'), '149': ('E:min', '4'), '150': ('E:min', '4'), '151': ('A:min', '4'), '152': ('A:min', '4'), '153': ('G:maj', '4'), '154': ('G:maj', '4'), '155': ('B:min', '4'), '156': ('B:min', '4'), '157': ('E:min', '4'), '158': ('E:min', '4'), '159': ('A:min', '4'), '160': ('A:min', '4'), '161': ('G:maj', '4'), '162': ('G:maj', '4'), '163': ('G:maj', '4'), '164': ('G:maj', '4'), '165': ('E:min', '4'), '166': ('E:min', '4'), '167': ('D:maj', '4'), '168': ('D:maj', '4'), '169': ('E:min', '4'), '170': ('E:min', '4'), '171': ('D:maj', '4'), '172': ('D:maj', '4'), '173': ('E:min', '4'), '174': ('E:min', '4'), '175': ('D:maj', '4'), '176': ('D:maj', '4'), '177': ('C:maj', '4'), '178': ('C:maj', '4'), '179': ('C:maj', '4'), '180': ('C:maj', '4'), '181': ('E:min', '4'), '182': ('E:min', '4'), '183': ('D:maj', '4'), '184': ('D:maj', '4'), '185': ('E:min', '4'), '186': ('E:min', '4'), '187': ('D:maj', '4'), '188': ('D:maj', '4'), '189': ('E:min', '4'), '190': ('E:min', '4'), '191': ('D:maj', '4'), '192': ('D:maj', '4'), '193': ('C:maj', '4'), '194': ('C:maj', '4'), '195': ('C:maj', '4'), '196': ('C:maj', '4'), '197': ('G:maj', '4'), '198': ('G:maj', '4'), '199': ('D:maj', '4'), '200': ('D:maj', '4'), '201': ('A:min', '4'), '202': ('E:min', '4'), '203': ('G:maj', '4'), '204': ('G:maj', '4'), '205': ('D:maj', '4'), '206': ('D:maj', '4'), '207': ('A:min', '4'), '208': ('A:min', '4'), '209': ('E:min', '4'), '210': ('E:min', '4'), '211': ('G:maj', '4'), '212': ('G:maj', '4'), '213': ('D:maj', '4'), '214': ('D:maj', '4'), '215': ('A:min', '4'), '216': ('A:min', '4'), '217': ('E:min', '4'), '218': ('E:min', '4'), '219': ('G:maj', '4'), '220': ('G:maj', '4'), '221': ('D:maj', '4'), '222': ('D:maj', '4'), '223': ('A:min', '4'), '224': ('A:min', '4'), '225': ('E:min', '4'), '226': ('E:min', '4'), '227': ('G:maj', '4'), '228': ('G:maj', '4'), '229': ('D:maj', '4'), '230': ('D:maj', '4'), '231': ('A:min', '4'), '232': ('A:min', '4'), '233': ('E:min', '4'), '234': ('E:min', '4'), '235': ('G:maj', '4'), '236': ('G:maj', '4'), '237': ('D:maj', '4'), '238': ('D:maj', '4'), '239': ('A:min', '4'), '240': ('A:min', '4'), '241': ('E:min', '4'), '242': ('E:min', '4'), '243': ('G:maj', '4'), '244': ('G:maj', '4'), '245': ('D:maj', '4'), '246': ('D:maj', '4'), '247': ('A:min', '4'), '248': ('A:min', '4'), '249': ('E:min', '4'), '250': ('E:min', '4'), '251': ('G:maj', '4'), '252': ('G:maj', '4'), '253': ('D:maj', '4'), '254': ('D:maj', '4'), '255': ('A:min', '4'), '256': ('A:min', '4'), '257': ('E:min', '4'), '258': ('E:min', '4'), '259': ('G:maj', '4'), '260': ('G:maj', '4'), '261': ('D:maj', '4'), '262': ('D:maj', '4'), '263': ('A:min', '4'), '264': ('A:min', '4'), '265': ('E:min', '4'), '266': ('E:min', '4'), '267': ('G:maj', '4'), '268': ('G:maj', '4'), '269': ('D:maj', '4'), '270': ('D:maj', '4'), '271': ('A:min', '4'), '272': ('A:min', '4'), '273': ('E:min', '4'), '274': ('E:min', '4'), '275': ('G:maj', '4'), '276': ('G:maj', '4'), '277': ('D:maj', '4'), '278': ('D:maj', '4'), '279': ('A:min', '4'), '280': ('A:min', '4'), '281': ('E:min', '4'), '282': ('E:min', '4'), '283': ('G:maj', '4'), '284': ('G:maj', '4'), '285': ('D:maj', '4'), '286': ('D:maj', '4'), '287': ('A:min', '4'), '288': ('A:min', '4'), '289': ('E:min', '4'), '290': ('E:min', '4'), '291': ('E:min', '4'), '292': ('E:min', '4'), '293': ('N', '4'), '294': ('N', '4'), '295': ('N', '4'), '296': ('N', '4'), '297': ('N', '4'), '298': ('N', '4'), '299': ('N', '4'), '300': ('N', '4'), '301': ('N', '4'), '302': ('N', '4')}
#print(my_dict)

# Initialize an empty list
extracted_strings = []

# Iterate through the dictionary items
for key, value in my_dict.items():
    extracted_strings.append(value[0])  # Append the first element of the tuple

# Print the extracted strings
#print(extracted_strings)

# Given list of strings
original_list = extracted_strings

# Remove semicolons from each string
cleaned_list = [s.replace(':', '') for s in original_list]

# Print the modified list
print(cleaned_list)

from pychord import Chord

def chords_to_notes(chord_list):
    """
    Given a list of chord names, returns a list of corresponding notes.
    """
    notes_list = []
    for chord_name in chord_list:
        if chord_name == 'N':
            # Handle the special case of a rest
            # You can customize how you want to represent the rest (e.g., silence)
            # For now, let's use an empty string to represent the rest
            notes_list.append('')
        else:
            try:
                chord = Chord(chord_name)
                notes = chord.components()
                # Filter out numeric indices (only keep strings)
                notes = [note for note in notes if isinstance(note, str)]
                notes_list.extend(notes)
            except ValueError:
                # Handle invalid chord names gracefully
                pass
    return notes_list

# Example chord list
chord_names = cleaned_list

resulting_notes = chords_to_notes(chord_names)
# Print the resulting notes
print(resulting_notes)

#creating audio file
chord_progression = ["Cmaj7", "Cmaj7", "Fmaj7", "Gdom7"]

#extract unique song titles and their corresponding notes
song_titles = df['Song Title']
song_notes = df['Notes'].str.split(', ').explode()

#initialize constants
NOTES = ['C', 'C#', 'D', 'Eb', 'E', 'F', 'F#', 'G', 'Ab', 'A', 'Bb', 'B']
OCTAVES = list(range(11))
NOTES_IN_OCTAVE = len(NOTES)

#accounts for any errors and organizes the notes names a bit better
errors = {
    'notes': 'Bad input, please refer this spec-\n'
}

def swap_accidentals(note):
    if note == 'Db':
        return 'C#'
    if note == 'D#':
        return 'Eb'
    if note == 'E#':
        return 'F'
    if note == 'Gb':
        return 'F#'
    if note == 'G#':
        return 'Ab'
    if note == 'A#':
        return 'Bb'
    if note == 'B#':
        return 'C'

    return note

def note_to_number(note: str, octave: int) -> int:
    note = swap_accidentals(note)
    assert note in NOTES, errors['notes']
    assert octave in OCTAVES, errors['notes']

    note = NOTES.index(note)
    note += (NOTES_IN_OCTAVE * octave)

    assert 0 <= note <= 127, errors['notes']

    return note

array_of_notes = []
for chord in chord_progression:
    array_of_notes.extend(chords.from_shorthand(chord))

array_of_note_numbers = []
for note in array_of_notes:
    OCTAVE = 4
    array_of_note_numbers.append(note_to_number(note, OCTAVE))

#extra information for the song
track = 0
channel = 0
time = 0  # In beats
duration = 1  # In beats
tempo = 120  # In BPM
volume = 100  # 0-127, as per the MIDI standard

#generate chord progression based on a specific song title 
selected_song_title = 'Song 1' #update so that it allows for user input (Song 1 is a filler title from the random csv file I created above)
selected_notes = song_notes[song_titles == selected_song_title]

chord_progression = []  #initialize an empty list

#create chords from the selected notes
for note in selected_notes:
    chord_progression.append(f"{note}maj7")  #assuming all chords are maj7

#creates our file to be outputed
with open(f"{selected_song_title}.mid", "wb") as output_file:
    MyMIDI.writeFile(output_file)
